{"version":3,"sources":["logo.svg","loading.svg","Button.js","AlbumCover.js","App.js","registerServiceWorker.js","index.js"],"names":["module","exports","Button","props","onClick","children","AlbumCover","track","src","album","images","url","style","width","height","getRandomNumber","x","Math","floor","random","App","useState","currentTrack","setCurrentTrack","songsLoaded","setSongsLoaded","total","setTotal","tracks","setTracks","timer","useEffect","fetch","method","headers","Authorization","then","response","json","data","items","length","clearTimeout","setTimeout","selectNewTrackToGuess","loading","className","alt","displayedTracks","array","counter","index","temp","shuffleArray","logo","name","preview_url","playStatus","Sound","status","PLAYING","map","id","key","swal","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","catch","error","ReactDOM","render","document","getElementById","URL","process","origin","addEventListener","get","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.f74a0f0e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.79f6b6a0.svg\";","module.exports = __webpack_public_path__ + \"static/media/loading.9d4cbf40.svg\";","import React from 'react';\nimport './Button.css';\n\nconst Button = (props) => (\n\t<button onClick={props.onClick}>{props.children}</button>\n);\n\nexport default Button;\n","import React from 'react';\n\nconst AlbumCover = ({ track }) => {\n\treturn (\n\t\t<img src={track.album.images[0].url} style={{ width: 400, height: 400 }} />\n\t);\n};\n\nexport default AlbumCover;\n","/*global swal*/\n\nimport React, { useState, useEffect } from 'react';\nimport logo from './logo.svg';\nimport loading from './loading.svg';\nimport './App.css';\nimport Sound from 'react-sound';\nimport Button from './Button';\nimport AlbumCover from './AlbumCover';\n\nconst apiToken =\n\t'BQAKSjt6dftLeYUvjzYTS6ffZlV8zZ492L7T1XSrHSnmb8efqun_pAEiClod9cPqZ2LIJUyGtt3b0FuH6afcXW7n-BFqk2WTMB5oQFgHFwFcNeA19djSfSIcKgvZ-835aAHUPz09ySxHhkUg-bx73Pm7VWVM';\n\nfunction shuffleArray(array) {\n\tlet counter = array.length;\n\n\twhile (counter > 0) {\n\t\tlet index = getRandomNumber(counter);\n\t\tcounter--;\n\t\tlet temp = array[counter];\n\t\tarray[counter] = array[index];\n\t\tarray[index] = temp;\n\t}\n\n\treturn array;\n}\n\n/* Return a random number between 0 included and x excluded */\nfunction getRandomNumber(x) {\n\treturn Math.floor(Math.random() * x);\n}\n\nconst App = () => {\n\tconst [currentTrack, setCurrentTrack] = useState();\n\tconst [songsLoaded, setSongsLoaded] = useState(false);\n\tconst [total, setTotal] = useState(0);\n\tconst [tracks, setTracks] = useState([]);\n\tlet timer = null;\n\n\tuseEffect(() => {\n\t\tfetch('https://api.spotify.com/v1/me/tracks', {\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\tAuthorization: 'Bearer ' + apiToken,\n\t\t\t},\n\t\t})\n\t\t\t.then((response) => response.json())\n\t\t\t.then((data) => {\n\t\t\t\tsetTracks(data.items);\n\t\t\t\tsetTotal(data.total);\n\t\t\t\tsetCurrentTrack(data.items[getRandomNumber(data.items.length)].track);\n\t\t\t\tsetSongsLoaded(true);\n\t\t\t});\n\t}, []);\n\n\tuseEffect(() => {\n\t\tclearTimeout(timer);\n\t\ttimer = setTimeout(() => selectNewTrackToGuess(), 30000);\n\t}, [currentTrack]);\n\n\tconst selectNewTrackToGuess = () => {\n\t\tif (tracks.length) {\n\t\t\tsetCurrentTrack(tracks[getRandomNumber(tracks.length)].track);\n\t\t}\n\t};\n\n\tconst checkAnswer = (responseTrackId) => {\n\t\tif (responseTrackId === currentTrack.id) {\n\t\t\tclearTimeout(timer);\n\t\t\tswal('Bravo 🎉', 'Bosh Like a Boss', 'success').then(\n\t\t\t\tselectNewTrackToGuess\n\t\t\t);\n\t\t} else {\n\t\t\tswal('Mauvaise pioche 😜', 'Essaye encore', 'error');\n\t\t}\n\t};\n\n\tif (!songsLoaded) {\n\t\treturn <img src={loading} className='App-logo' alt='loading' />;\n\t}\n\n\tconst displayedTracks = shuffleArray([\n\t\tcurrentTrack,\n\t\ttracks[getRandomNumber(tracks.length)].track,\n\t\ttracks[getRandomNumber(tracks.length)].track,\n\t]);\n\n\treturn (\n\t\t<div className='App'>\n\t\t\t<header className='App-header'>\n\t\t\t\t<img src={logo} className='App-logo' alt='logo' />\n\t\t\t\t<h1 className='App-title'>Nous avons retrouvé {total} musiques!</h1>\n\t\t\t</header>\n\t\t\t<div className='App-images'>\n\t\t\t\t<p>Votre premiere chanson ♥️: {currentTrack.name} </p>\n\t\t\t\t<AlbumCover track={currentTrack} />\n\t\t\t\t<Sound\n\t\t\t\t\turl={currentTrack.preview_url}\n\t\t\t\t\tplayStatus={Sound.status.PLAYING}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<div className='App-buttons'>\n\t\t\t\t{displayedTracks.map(({ id, name }, index) => (\n\t\t\t\t\t<Button\n\t\t\t\t\t\tkey={`${currentTrack.id}${id}${index}`}\n\t\t\t\t\t\tonClick={() => checkAnswer(id)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{name}\n\t\t\t\t\t</Button>\n\t\t\t\t))}\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n\twindow.location.hostname === 'localhost' ||\n\t\t// [::1] is the IPv6 localhost address.\n\t\twindow.location.hostname === '[::1]' ||\n\t\t// 127.0.0.1/8 is considered localhost for IPv4.\n\t\twindow.location.hostname.match(\n\t\t\t/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n\t\t)\n);\n\nexport default function register() {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Lets check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl);\n\t\t\t} else {\n\t\t\t\t// Is not local host. Just register service worker\n\t\t\t\tregisterValidSW(swUrl);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction registerValidSW(swUrl) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then((registration) => {\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the old content will have been purged and\n\t\t\t\t\t\t\t// the fresh content will have been added to the cache.\n\t\t\t\t\t\t\t// It's the perfect time to display a \"New content is\n\t\t\t\t\t\t\t// available; please refresh.\" message in your web app.\n\t\t\t\t\t\t\tconsole.log('New content is available; please refresh.');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\tconsole.log('Content is cached for offline use.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error('Error during service worker registration:', error);\n\t\t});\n}\n\nfunction checkValidServiceWorker(swUrl) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl)\n\t\t.then((response) => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tif (\n\t\t\t\tresponse.status === 404 ||\n\t\t\t\tresponse.headers.get('content-type').indexOf('javascript') === -1\n\t\t\t) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\t\tconsole.log(\n\t\t\t\t'No internet connection found. App is running in offline mode.'\n\t\t\t);\n\t\t});\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\tregistration.unregister();\n\t\t});\n\t}\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\nregisterServiceWorker();\n"],"sourceRoot":""}